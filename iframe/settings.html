<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settings - Beautify PCB</title>
    <style>
        :root {
            --primary: #4285f4;
            --primary-hover: #3367d6;
            --danger: #dc3545;
            --text: #333;
            --text-secondary: #666;
            --text-hint: #999;
            --border: #e0e0e0;
            --bg: #f5f7fa;
            --card-bg: #fff;
            --input-bg: #f9f9f9;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 13px;
            color: var(--text);
            background-color: var(--bg);
            margin: 0;
            padding: 16px;
            overflow-x: hidden;
        }

        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .card-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 20px;
            padding-left: 8px;
            border-left: 3px solid var(--primary);
            line-height: 1;
            color: #202124;
        }

        .setting-item {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-info {
            flex: 1;
            padding-right: 24px;
        }

        .setting-label {
            display: block;
            font-weight: 500;
            font-size: 13px;
            margin-bottom: 4px;
            color: var(--text);
        }

        .setting-desc {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .setting-control {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
        }

        /* Input Groups */
        .input-group {
            display: flex;
            align-items: center;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--input-bg);
            overflow: hidden;
            width: 140px;
            transition: border-color 0.2s;
        }
        
        .input-group:focus-within {
            border-color: var(--primary);
            background: #fff;
        }

        .input-group input {
            border: none;
            padding: 8px 10px;
            width: 100%;
            outline: none;
            background: transparent;
            font-size: 13px;
            color: var(--text);
            text-align: right;
        }

        .input-group .addon, .input-group select {
            background: #eee;
            border: none;
            border-left: 1px solid var(--border);
            padding: 0 10px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            outline: none;
            font-weight: 500;
        }
        
        .input-group select {
            cursor: pointer;
            padding-right: 4px;
        }

        /* Toggle Switch */
        .switch-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .switch-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            border: 1px solid transparent;
            outline: none;
        }

        .btn-white {
            background: #fff;
            border-color: var(--border);
            color: var(--text);
        }

        .btn-white:hover {
            background: #f8f8f8;
            border-color: #ccc;
        }

        .btn-primary {
            background: var(--primary);
            color: #fff;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-danger {
            background: #fff;
            color: var(--danger);
            border-color: #ffdce0;
        }

        .btn-danger:hover {
            background: #fff5f5;
            border-color: var(--danger);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
        }
        
        .btn-ghost:hover {
            background: rgba(0,0,0,0.05);
            color: var(--text);
        }

        /* Snapshot specific */
        .snapshot-container {
            border: 1px solid var(--border);
            border-radius: 6px;
            min-height: 100px;
            max-height: 180px;
            overflow-y: auto;
            background: #fafafa;
            margin-top: 12px;
        }

        .snapshot-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100px;
            color: var(--text-hint);
            font-size: 12px;
        }

        .snapshot-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid #eee;
            background: #fff;
            transition: background 0.2s;
        }
        
        .snapshot-item:hover {
            background: #f0f7ff;
        }
        
        .snapshot-item:last-child {
            border-bottom: none;
        }

        .snapshot-meta {
            font-weight: 500;
            font-size: 13px;
            margin-bottom: 2px;
            color: var(--text);
        }
        
        .snapshot-details {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .footer-status {
            margin-top: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #28a745;
            font-weight: 500;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: #323232;
            color: #fff;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 13px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, 10px);
        }
        
        .toast.show {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        /* Animation */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .rotating { animation: spin 0.6s cubic-bezier(0.4, 0.0, 0.2, 1) infinite; display: inline-block; pointer-events: none; }
    </style>
</head>
<body>

    <!-- General Settings -->
    <div class="card">
        <div class="card-title" data-i18n="通用设置">General Settings</div>

        <!-- Radius -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label" data-i18n="最大圆角半径">Max Corner Radius</div>
                <div class="setting-desc" data-i18n="控制圆弧过渡的最大半径大小">Controls the maximum arc transition radius</div>
            </div>
            <div class="setting-control">
                <div class="input-group">
                    <input type="text" id="cornerRadius" data-min="0.1" data-step="1" value="500">
                    <select id="unitSelect">
                        <option value="mil" selected>mil</option>
                        <option value="mm">mm</option>
                    </select>
                </div>
            </div>
        </div>



        <!-- Sync Width -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label" data-i18n="自动线宽过渡">Auto Width Transition</div>
                <div class="setting-desc" data-i18n="圆滑时处理不同线宽">Automatically handle different widths when smoothing routing</div>
            </div>
            <div class="setting-control">
                <div class="switch-container">
                    <label class="switch">
                        <input type="checkbox" id="syncWidthTransition">
                        <span class="slider"></span>
                    </label>
                    <span class="switch-label" id="syncWidthLabel" data-i18n="启用">Enable</span>
                </div>
            </div>
        </div>

        <!-- Segments -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label" data-i18n="最大过渡段数">Max Transition Segments</div>
                <div class="setting-desc" data-i18n="防止段数过多导致卡顿">Max gradient segments for width transition, prevents lag from too many segments</div>
            </div>
            <div class="setting-control">
                <div class="input-group">
                    <input type="text" id="widthTransitionSegments" data-min="5" data-max="100" data-step="1" value="25">
                    <span class="addon" data-i18n="段">segments</span>
                </div>
            </div>
        </div>

        <!-- Ratio -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label" data-i18n="过渡长度最大比例">Max Transition Ratio</div>
                <div class="setting-desc" data-i18n="过渡区长度比率">Max ratio of transition length to width difference; actual length won't exceed narrow track length</div>
            </div>
            <div class="setting-control">
                <div class="input-group">
                    <input type="text" id="widthTransitionRatio" data-min="0.5" data-max="10" data-step="0.1" value="2.5">
                    <span class="addon">X</span>
                </div>
            </div>
        </div>
    </div>

    <!-- DRC Settings -->
    <div class="card">
        <div class="card-title" data-i18n="设计规则检查 (DRC)">Design Rule Check (DRC)</div>
        
        <!-- Enable DRC -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label" data-i18n="启用安全检查">Enable Safety Check</div>
                <div class="setting-desc" data-i18n="生成圆弧时检查是否违反间距规则">Check spacing rule violations when generating arcs (against nearby Pads/Tracks)</div>
            </div>
            <div class="setting-control">
                <div class="switch-container">
                    <label class="switch">
                        <input type="checkbox" id="enableDRC">
                        <span class="slider"></span>
                    </label>
                    <span class="switch-label" id="enableDRCLabel" data-i18n="启用">Enable</span>
                </div>
            </div>
        </div>

        <!-- Clearance -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label" data-i18n="安全间距">Safety Clearance</div>
                <div class="setting-desc" data-i18n="圆弧与周围物体的最小距离">Minimum distance between arcs and surrounding objects (recommend 6mil+)</div>
            </div>
            <div class="setting-control">
                <div class="input-group">
                    <input type="text" id="drcClearance" data-min="0" data-step="1" value="6">
                    <span class="addon">mil</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Advanced -->
    <div class="card">
        <div class="card-title" data-i18n="高级设置">Advanced Settings</div>

        <!-- Merge Short Segments -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label">
                    <span data-i18n="合并短线段">Merge Short Segments</span>
                    <span style="background:#fff3e0;color:#ef6c00;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:6px;">Beta</span>
                </div>
                <div class="setting-desc" data-i18n="自动合并过短的中间线段以生成圆弧">Automatically merge short intermediate segments to generate arcs</div>
            </div>
            <div class="setting-control">
                <div class="switch-container">
                    <label class="switch">
                        <input type="checkbox" id="mergeShortSegments" checked>
                        <span class="slider"></span>
                    </label>
                    <span class="switch-label" id="mergeShortSegmentsLabel" data-i18n="启用">Enable</span>
                </div>
            </div>
        </div>

        <!-- Force Arc -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label">
                    <span data-i18n="强制生成圆弧">Force Arc Generation</span>
                    <span style="background:#fff3e0;color:#ef6c00;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:6px;">Beta</span>
                </div>
                <div class="setting-desc" data-i18n="短线段导致圆弧不相切也生成（半径减小）">Generate even if segment is too short (reduce radius)</div>
            </div>
            <div class="setting-control">
                <div class="switch-container">
                    <label class="switch">
                        <input type="checkbox" id="forceArc" checked>
                        <span class="slider"></span>
                    </label>
                    <span class="switch-label" id="forceArcLabel" data-i18n="启用">Enable</span>
                </div>
            </div>
        </div>

        <!-- Debug -->
        <div class="setting-item">
            <div class="setting-info">
                <div class="setting-label" data-i18n="调试模式">Debug Mode</div>
                <div class="setting-desc" data-i18n="启用调试日志">Print detailed logs in the console</div>
            </div>
            <div class="setting-control">
                <div class="switch-container">
                    <label class="switch">
                        <input type="checkbox" id="debug">
                        <span class="slider"></span>
                    </label>
                    <span class="switch-label" id="debugLabel" data-i18n="启用">Enable</span>
                </div>
            </div>
        </div>

        <!-- Snapshot -->
    </div>

    <div class="card">
        <div class="card-title">
            <span data-i18n="布线状态管理">Snapshot Manager</span>
            <span id="snapshotCount" style="font-weight: normal; color: var(--text-hint); font-size: 12px; margin-left: 4px;"></span>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <!-- View Toggle -->
            <div class="filter-bar" style="display: flex; gap: 4px; background: #eee; padding: 4px; border-radius: 6px;">
                <button id="btnShowManual" class="btn btn-ghost" style="padding: 4px 10px; font-size: 12px; border-radius: 4px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.1); color: var(--primary);" data-i18n="手动快照">Manual Snapshots</button>
                <button id="btnShowAuto" class="btn btn-ghost" style="padding: 4px 10px; font-size: 12px; border-radius: 4px; color: var(--text-secondary);" data-i18n="自动快照">Auto Snapshots</button>
                <div style="width: 1px; background: #ddd; margin: 2px 0;"></div>
                <button type="button" class="btn btn-ghost" id="refreshSnapshotBtn" style="padding: 4px 10px; font-size: 16px; line-height: 1; border-radius: 4px;" title="Refresh list"><span class="refresh-icon" style="display:inline-block">&#8635;</span></button>
            </div>

            <!-- Actions -->
            <div style="display: flex; gap: 8px;">
                <button type="button" class="btn btn-primary" id="createSnapshotBtn" style="padding: 4px 12px; font-size: 12px;" data-i18n="新增快照">New Snapshot</button>
                <button type="button" class="btn btn-danger" id="clearSnapshotsBtn" style="padding: 4px 12px; font-size: 12px;" data-i18n="清除手动">Clear Manual</button>
            </div>
        </div>

        <div id="snapshotList" class="snapshot-container">
            <div class="snapshot-placeholder" data-i18n="暂无快照">No Snapshots</div>
        </div>
    </div>

    <div class="footer-status">
        <div class="status-badge" id="saveStatus">
            <span style="font-size: 14px;"></span> 
            <span data-i18n="设置即时生效">Settings take effect immediately</span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; color: var(--text-hint); font-size: 12px;">
            <span><span data-i18n="作者">Author</span>: <span style="font-weight: 500; color: var(--text-secondary);">m-RNA</span></span>
            <span style="color: #ddd;">|</span>
            <a href="javascript:void(0)" onclick="openUrl('https://github.com/m-RNA/Easy_EDA_PCB_Beautify')" style="color: var(--primary); text-decoration: none; border-bottom: 1px dashed var(--primary);">GitHub</a>
        </div>
        <button type="button" class="btn btn-white" id="closeBtn" onclick="tryClose()" data-i18n="关闭" style="min-width: 120px;">Close</button>
    </div>
    
    <div id="toast" class="toast">Settings Saved</div>

    <script>
		/* global eda */

        // Helper to find the API object
        function getEda() {
            if (typeof eda !== 'undefined')
                return eda;
            if (window.parent && typeof window.parent.eda !== 'undefined')
                return window.parent.eda;
            if (window.top && typeof window.top.eda !== 'undefined')
                return window.top.eda;
            return null;
        }
        
        const API = getEda();

        if (!API) {
            console.error('JLC EDA API not found!');
            // Show visible error
            const errDiv = document.createElement('div');
            errDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;padding:10px;background:#ffebee;color:#c62828;text-align:center;z-index:9999;border-bottom:1px solid #ef9a9a;';
            errDiv.textContent = 'Error: Cannot connect to JLC EDA API. Please try reloading the extension.';
            document.body.prepend(errDiv);
        }

        function tryClose() {
            const api = API || getEda();
            if (api && api.sys_IFrame && api.sys_IFrame.closeIFrame) {
                api.sys_IFrame.closeIFrame('settings');
            }
            else {
                console.log('Close requested (API missing)');
            }
        }

        function openUrl(url) {
            const api = API || getEda();
            if (api && api.sys_Window && typeof api.sys_Window.openUrl === 'function') {
                api.sys_Window.openUrl(url);
            } else {
                window.open(url, '_blank');
            }
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        function translatePage() {
            const api = API || getEda();
            if (!api || typeof api.sys_I18n === 'undefined')
                return;

            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach((el) => {
                const key = el.getAttribute('data-i18n');
                if (key) {
                    const text = api.sys_I18n.text(key);
                    if (text && text !== key) {
                        if (el.tagName === 'INPUT' && el.type === 'placeholder') {
                            el.placeholder = text;
                        }
                        else {
                            // Don't overwrite if it has children like the switch slider, unless it's just text
                            if (el.children.length === 0) {
                                el.textContent = text;
                            }
                        }
                    }
                }
            });
            document.title = api.sys_I18n.text('设置');
        }

        // Elements
        const elCornerRadius = document.getElementById('cornerRadius');
        const elUnitSelect = document.getElementById('unitSelect');
        const elSyncWidth = document.getElementById('syncWidthTransition');
        const elSegments = document.getElementById('widthTransitionSegments');
        const elRatio = document.getElementById('widthTransitionRatio');
        const elDebug = document.getElementById('debug');
        const elForceArc = document.getElementById('forceArc');
        const elMergeShortSegments = document.getElementById('mergeShortSegments');
        const elEnableDRC = document.getElementById('enableDRC');
        const elDrcClearance = document.getElementById('drcClearance');

        // I18n labels update
        const elSyncWidthLabel = document.getElementById('syncWidthLabel');
        const elDebugLabel = document.getElementById('debugLabel');
        const elMergeShortSegmentsLabel = document.getElementById('mergeShortSegmentsLabel');
        const elForceArcLabel = document.getElementById('forceArcLabel');
        const elEnableDRCLabel = document.getElementById('enableDRCLabel');

        // Default config (will be loaded from API during init)
        let DEFAULT_CONFIG = {};

        let currentUnitState = 'mil';

        function updateSwitchLabels() {
            const api = API || getEda();
            const enabledText = (api && api.sys_I18n) ? api.sys_I18n.text('启用') : 'Enable';
            const disabledText = (api && api.sys_I18n) ? api.sys_I18n.text('禁用') : 'Disable';

            elSyncWidthLabel.textContent = elSyncWidth.checked ? enabledText : disabledText;
            elDebugLabel.textContent = elDebug.checked ? enabledText : disabledText;
            elMergeShortSegmentsLabel.textContent = elMergeShortSegments.checked ? enabledText : disabledText;
            elForceArcLabel.textContent = elForceArc.checked ? enabledText : disabledText;
            elEnableDRCLabel.textContent = elEnableDRC.checked ? enabledText : disabledText;

            // Visual feedback color for label
            elSyncWidthLabel.style.color = elSyncWidth.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elDebugLabel.style.color = elDebug.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elMergeShortSegmentsLabel.style.color = elMergeShortSegments.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elForceArcLabel.style.color = elForceArc.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elEnableDRCLabel.style.color = elEnableDRC.checked ? 'var(--primary)' : 'var(--text-secondary)';
        }

        // Load settings from storage
        async function loadSettings() {
            const api = API || getEda();
            if (!api)
                return;

            // Try to sync default config
            if (typeof api.jlc_eda_beautify_getDefaultSettings === 'function') {
                try {
                    DEFAULT_CONFIG = api.jlc_eda_beautify_getDefaultSettings();
                    console.log('Loaded defaults from API', DEFAULT_CONFIG);
                }
                catch (e) {
                    console.error('Failed to load defaults', e);
                }
            }

            try {
                const settings = await api.sys_Storage.getExtensionAllUserConfigs() || {};
                const config = {
                    ...DEFAULT_CONFIG,
                    ...settings,
                };

                // Ensure default unit is mil if not set (fixing default startup state)
                if (!config.unit)
                    config.unit = 'mil';

                elCornerRadius.value = config.cornerRadius;
                elCornerRadius.setAttribute('data-last-valid', config.cornerRadius);

                elUnitSelect.value = config.unit;
                currentUnitState = config.unit;

                // Initialize step based on unit for keyboard/custom stepper
                if (currentUnitState === 'mm') {
                    // 0.1 mm step
                    elCornerRadius.setAttribute('data-step', '0.1');
                }
                else {
                    // 1 mil step
                    elCornerRadius.setAttribute('data-step', '1');
                }

                elMergeShortSegments.checked = config.mergeShortSegments !== undefined ? config.mergeShortSegments : true;
                elSyncWidth.checked = config.syncWidthTransition;

                elSegments.value = config.widthTransitionSegments;
                elSegments.setAttribute('data-last-valid', config.widthTransitionSegments);

                elRatio.value = config.widthTransitionRatio;
                elRatio.setAttribute('data-last-valid', config.widthTransitionRatio);

                elDebug.checked = config.debug;
                elForceArc.checked = config.forceArc !== undefined ? config.forceArc : true;

                // DRC
                elEnableDRC.checked = config.enableDRC !== undefined ? config.enableDRC : false;
                elDrcClearance.value = config.drcClearance !== undefined ? config.drcClearance : 6;
                elDrcClearance.setAttribute('data-last-valid', elDrcClearance.value);

                updateSwitchLabels();
            }
            catch (e) {
                console.error(e);
            }
        }

        // Save settings to storage
        async function saveSettings(silent = false) {
            const api = API || getEda();
            if (!api)
                return;

            // Validate numbers
            let radius = Number.parseFloat(elCornerRadius.value);
            if (Number.isNaN(radius))
                radius = DEFAULT_CONFIG.cornerRadius;

            let segments = Number.parseInt(elSegments.value);
            if (Number.isNaN(segments) || segments < 1)
                segments = DEFAULT_CONFIG.widthTransitionSegments;

            let ratio = Number.parseFloat(elRatio.value);
            if (Number.isNaN(ratio))
                ratio = DEFAULT_CONFIG.widthTransitionRatio;

            let clearance = Number.parseFloat(elDrcClearance.value);
            if (Number.isNaN(clearance))
                clearance = 6;

            const settings = {
                cornerRadius: radius,
                unit: elUnitSelect.value,
                mergeShortSegments: elMergeShortSegments.checked,
                syncWidthTransition: elSyncWidth.checked,
                widthTransitionSegments: segments,
                widthTransitionRatio: ratio,
                debug: elDebug.checked,
                forceArc: elForceArc.checked,
                enableDRC: elEnableDRC.checked,
                drcClearance: clearance
            };

            try {
                await api.sys_Storage.setExtensionAllUserConfigs(settings);
                updateSwitchLabels();

                // Notify the main extension process to refresh settings cache
                if (typeof api.jlc_eda_beautify_refreshSettings === 'function') {
                    await api.jlc_eda_beautify_refreshSettings();
                }

                if (!silent) {
                    const msg = api.sys_I18n ? api.sys_I18n.text('已保存') : 'Saved';
                    showToast(msg);
                }
            }
            catch (e) {
                console.error('Save failed:', e);
            }
        }

        // Bind Events
        function bindSmartInput(el, isInt = false) {
            function validateAndSave() {
                let val = el.value.trim();
                if (!val) {
                    el.value = el.getAttribute('data-last-valid') || (isInt ? '0' : '0.0');
                    return;
                }

                // Check for math operators (Supports +, -, *, /, ())
                if (/[+\-*/]/.test(val)) {
                    try {
                        // Security check: strictly limit allowed characters
                        if (/^[0-9.+\-*/()\s]+$/.test(val)) {
                            // eslint-disable-next-line no-new-func
                            let result = new Function(`return ${val}`)();
                            if (Number.isFinite(result)) {
                                if (isInt) {
                                    result = Math.round(result);
                                }
                                else {
                                    // Allow up to 3 decimal places
                                    result = Number.parseFloat(result.toFixed(3));
                                }
                                el.value = result;
                                val = String(result);
                            }
                            else {
                                // Calculation resulted in error/infinity, revert
                                el.value = el.getAttribute('data-last-valid');
                                return;
                            }
                        }
                        else {
                            // Illegal characters found, revert
                            el.value = el.getAttribute('data-last-valid');
                            return;
                        }
                    }
                    catch {
                        // Eval failed, revert
                        el.value = el.getAttribute('data-last-valid');
                        return;
                    }
                }

                let num = Number.parseFloat(val);

                if (Number.isNaN(num)) {
                    el.value = el.getAttribute('data-last-valid');
                    return;
                }

                const min = Number.parseFloat(el.getAttribute('data-min') || '-99999999');
                const max = Number.parseFloat(el.getAttribute('data-max') || '99999999');

                if (num < min)
                    num = min;
                if (num > max)
                    num = max;

                if (isInt) {
                    num = Math.round(num);
                }
                else {
                    // Normalize to max 3 decimals
                    num = Number.parseFloat(num.toFixed(3));
                }

                el.value = num;

                // Check if actually changed to avoid redundant saves
                const last = Number.parseFloat(el.getAttribute('data-last-valid'));
                if (num !== last) {
                    el.setAttribute('data-last-valid', num);
                    saveSettings();
                }
            }

            // Unified step logic
            function applyStep(direction, multiplier) {
                // Don't step if current value is formula
                let val = el.value.trim();
                if (/[+\-*/]/.test(val)) {
                    validateAndSave();
                    val = el.value.trim();
                }

                let num = Number.parseFloat(val);
                if (Number.isNaN(num))
                    num = 0;

                let step = Number.parseFloat(el.getAttribute('data-step') || '1');
                if (Number.isNaN(step))
                    step = 1;

                step *= multiplier;

                if (direction > 0)
                    num += step; // up
                else num -= step; // down

                const min = Number.parseFloat(el.getAttribute('data-min') || '-99999999');
                const max = Number.parseFloat(el.getAttribute('data-max') || '99999999');

                if (num < min)
                    num = min;
                if (num > max)
                    num = max;

                if (isInt) {
                    num = Math.round(num);
                }
                else {
                    num = Number.parseFloat(num.toFixed(3));
                }

                el.value = num;
                el.setAttribute('data-last-valid', num);

                // Debounce save for rapid wheel/key events
                if (el.saveTimer)
                    clearTimeout(el.saveTimer);
                el.saveTimer = setTimeout(() => {
                    saveSettings();
                }, 300);
            }

            // Handle Keyboard stepping (Up/Down) since type="text" doesn't have it natively
            function handleKeyDown(e) {
                if (e.key === 'Enter') {
                    el.blur();
                    return;
                }

                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    applyStep(e.key === 'ArrowUp' ? 1 : -1, e.shiftKey ? 10 : 1);
                }
            }

            // Handle Mouse Wheel
            function handleWheel(e) {
                if (document.activeElement !== el)
                    return;
                e.preventDefault();
                // deltaY < 0 means scrolling up (increment)
                applyStep(e.deltaY < 0 ? 1 : -1, e.shiftKey ? 10 : 1);
            }

            el.addEventListener('change', validateAndSave);
            el.addEventListener('blur', validateAndSave);
            el.addEventListener('keydown', handleKeyDown);
            el.addEventListener('wheel', handleWheel, { passive: false });
        }

        bindSmartInput(elCornerRadius, false);
        bindSmartInput(elSegments, true);
        bindSmartInput(elRatio, false);
        bindSmartInput(elDrcClearance, false);

        [elSyncWidth, elDebug, elMergeShortSegments, elForceArc, elEnableDRC].forEach((el) => {
            el.addEventListener('change', () => saveSettings());
        });

        document.getElementById('closeBtn').addEventListener('click', tryClose);

        // Unit Conversion Logic
        elUnitSelect.addEventListener('change', (e) => {
            const newUnit = e.target.value;
            const val = Number.parseFloat(elCornerRadius.value);
            let newVal = val;

            // Adjust step and calculate new value
            if (newUnit === 'mm') {
                if (currentUnitState === 'mil')
                    newVal = val / 39.3701;
                elCornerRadius.setAttribute('data-step', '0.1');
            }
            else { // mil
                if (currentUnitState === 'mm')
                    newVal = val * 39.3701;
                elCornerRadius.setAttribute('data-step', '1');
            }

            // Format to reasonable precision (3 decimal places)
            elCornerRadius.value = Number.parseFloat(newVal.toFixed(3));
            elCornerRadius.setAttribute('data-last-valid', elCornerRadius.value);

            currentUnitState = newUnit;
            saveSettings();
        });

        // Snapshots
        const snapshotList = document.getElementById('snapshotList');
        let currentPcbId = null;

        // Periodically check for PCB document changes
        // View Mode State
        let currentViewType = 'manual';

        async function checkPcbChange() {
            const api = API || getEda();
            if (!api || !api.dmt_Pcb) return;
            try {
                let pid = null;
                const info = await api.dmt_Pcb.getCurrentPcbInfo();
                if (info) pid = info.uuid;
                else {
                    const boardInfo = await api.dmt_Board.getCurrentBoardInfo();
                    if (boardInfo && boardInfo.pcb) pid = boardInfo.pcb.uuid;
                }

                if (pid && pid !== currentPcbId) {
                    currentPcbId = pid;
                    
                    // Auto-refresh animation
                    const btn = document.getElementById('refreshSnapshotBtn');
                    const icon = btn ? btn.querySelector('.refresh-icon') : null;
                    if (icon) {
                        icon.classList.add('rotating');
                        setTimeout(() => icon.classList.remove('rotating'), 600);
                    }

                    refreshSnapshots(); // PCB changed, refresh list
                }
            } catch (e) { /* ignore */ }
        }
        setInterval(checkPcbChange, 2000);

        // Toggle Buttons
        const btnShowManual = document.getElementById('btnShowManual');
        const btnShowAuto = document.getElementById('btnShowAuto');

        function updateToggleStyles() {
            if (currentViewType === 'manual') {
                btnShowManual.style.background = '#fff';
                btnShowManual.style.color = 'var(--primary)';
                btnShowManual.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';
                
                btnShowAuto.style.background = 'transparent';
                btnShowAuto.style.color = 'var(--text-secondary)';
                btnShowAuto.style.boxShadow = 'none';
            } else {
                btnShowAuto.style.background = '#fff';
                btnShowAuto.style.color = 'var(--primary)';
                btnShowAuto.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';

                btnShowManual.style.background = 'transparent';
                btnShowManual.style.color = 'var(--text-secondary)';
                btnShowManual.style.boxShadow = 'none';
            }
        }

        if (btnShowManual && btnShowAuto) {
            btnShowManual.onclick = () => {
                if (currentViewType !== 'manual') {
                    currentViewType = 'manual';
                    updateToggleStyles();
                    refreshSnapshots();
                }
            };

            btnShowAuto.onclick = () => {
                if (currentViewType !== 'auto') {
                    currentViewType = 'auto';
                    updateToggleStyles();
                    refreshSnapshots();
                }
            };
        }

        async function refreshSnapshots() {
            const api = API || getEda();
            if (!api || !api.jlc_eda_beautify_snapshot)
                return;
                
            try {
                // Make sure we have the current PCB ID
                if (!currentPcbId) {
                   await checkPcbChange();
                }

                if (!currentPcbId) {
                     // Still no PCB - document may not be open
                     snapshotList.innerHTML = `<div class="snapshot-placeholder">${api.sys_I18n ? api.sys_I18n.text('请先打开PCB文档') : 'Please open a PCB document'}</div>`;
                     document.getElementById('snapshotCount').textContent = `(0/0)`;
                     return;
                }

                // Get snapshots based on current view mode
                const snapshots = await api.jlc_eda_beautify_snapshot.getSnapshots(currentPcbId, currentViewType);

                 console.log(`[Settings] Snapshots for PCB ${currentPcbId} (${currentViewType}): ${snapshots.length}`);

                // Update Count safely
                const countEl = document.getElementById('snapshotCount');
                // Get limit, default to 20
                const limit = (api.jlc_eda_beautify_snapshot && api.jlc_eda_beautify_snapshot.SNAPSHOT_LIMIT) ? api.jlc_eda_beautify_snapshot.SNAPSHOT_LIMIT : 20;

                if (countEl)
                    countEl.textContent = `(${snapshots.length}/${limit})`;

                // Fix: Sync the poller counter to avoid double-refresh on view toggle
                if (currentViewType === 'auto') {
                    lastSnapshotCount = snapshots.length;
                }

                snapshotList.innerHTML = '';
                if (snapshots.length === 0) {
                    const emptyText = api.sys_I18n ? api.sys_I18n.text('暂无快照') : 'No Snapshots';
                    snapshotList.innerHTML = `<div class="snapshot-placeholder">${emptyText}</div>`;
                    return;
                }

                // List is already sorted (if backend didn't sort, sort here again)
                const sorted = snapshots;
                
                // Get the last restored snapshot ID
                const lastRestoredId = api.jlc_eda_beautify_snapshot.getLastRestoredId ? api.jlc_eda_beautify_snapshot.getLastRestoredId() : null;

                sorted.forEach((snap, index) => {
                    const div = document.createElement('div');
                    div.className = 'snapshot-item';

                    const timeStr = new Date(snap.timestamp).toLocaleTimeString();
                    let nameStr = snap.name;
                    if (!nameStr) {
                        nameStr = api.sys_I18n ? api.sys_I18n.text('自动快照') : 'Auto Snapshot';
                    }
                    else if (api.sys_I18n && (nameStr === '手动快照' || nameStr === 'Manual Snapshot')) {
                        nameStr = api.sys_I18n.text(nameStr);
                    }

                    // If this is the last undone snapshot, add a badge
                    let badgeHtml = '';

                    const isLastRestored = lastRestoredId !== null && String(snap.id) === String(lastRestoredId);
                    if (isLastRestored) {
                        const undoText = api.sys_I18n ? api.sys_I18n.text('上次撤销至此') : 'Last Undo Point';
                        badgeHtml += `<span style="background:#e3f2fd;color:#1976d2;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:6px;">${undoText}</span>`;
                        console.log('[Settings] Badge shown for snapshot:', snap.id);
                    }

                    // If this is the latest snapshot
                    if (index === 0) {
                        const latestText = api.sys_I18n ? api.sys_I18n.text('最新') : 'Latest';
                        badgeHtml += `<span style="background:#e8f5e9;color:#2e7d32;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:6px;">${latestText}</span>`;
                    }

                    const recoverText = api.sys_I18n ? api.sys_I18n.text('恢复') : 'Restore';
                    const deleteText = api.sys_I18n ? api.sys_I18n.text('删除') : 'Delete';
                    const linesCount = snap.lines ? snap.lines.length : 0;
                    const arcsCount = snap.arcs ? snap.arcs.length : 0;
                    const linesText = `${linesCount} Lines, ${arcsCount} Arcs`;

                    div.innerHTML = `
                        <div style="flex:1;overflow:hidden;">
                            <div class="snapshot-meta">${nameStr}${badgeHtml}</div>
                            <div class="snapshot-details">${timeStr} · ${linesText}</div>
                        </div>
                        <div style="display:flex;gap:4px;">
                            <button type="button" class="btn btn-white btn-recover" style="padding:4px 10px;font-size:12px;">${recoverText}</button>
                            <button type="button" class="btn btn-ghost btn-delete" style="padding:4px 8px;font-size:12px;color:#d32f2f;" title="${deleteText}">&#10005;</button>
                        </div>
                    `;

                    // Recover Button
                    div.querySelector('.btn-recover').onclick = async () => {
                        // Call restore directly; pass true for backend confirmation dialogs
                        // This avoids conflicting popups from both UI and backend threads
                        try {
                            const result = await api.jlc_eda_beautify_snapshot.restoreSnapshot(snap.id, true, true);
                            if (result) {
                                const restoredText = api.sys_I18n ? api.sys_I18n.text('已恢复') : 'Restored';
                                showToast(restoredText);
                            }
                            // Don't show "Restore returned false" - user may have cancelled the dialog
                        }
                        catch (err) {
                            api.sys_Dialog.showInformationMessage(`Restore failed: ${err}`);
                        }
                    };

                    // Delete Button
                    div.querySelector('.btn-delete').onclick = (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        const confirmDelText = api.sys_I18n ? api.sys_I18n.text('确定要删除此快照吗？') : 'Delete this snapshot?';
                        if (api.sys_Dialog) {
                            api.sys_Dialog.showConfirmationMessage(confirmDelText, api.sys_I18n ? api.sys_I18n.text('删除快照') : 'Delete Snapshot', undefined, undefined, async (ok) => {
                                if (ok) {
                                    await api.jlc_eda_beautify_snapshot.deleteSnapshot(snap.id);
                                }
                            });
                        }
                    };

                    snapshotList.appendChild(div);
                });
            }
            catch (e) {
                console.error('Snapshot refresh error:', e);
                snapshotList.innerHTML = '<div style="padding:10px;color:red">Error loading snapshots</div>';
            }
        }

        document.getElementById('refreshSnapshotBtn').onclick = async function() {
            const btn = this;
            const icon = btn.querySelector('.refresh-icon'); 
            if (icon) icon.classList.add('rotating');
            
            try {
                // Force check for PCB ID changes
                await checkPcbChange();
                await refreshSnapshots();
            }
            finally {
                // Spin for at least 600ms (one full rotation)
                setTimeout(() => {
                    if (icon) icon.classList.remove('rotating');
                }, 600);
            }
        };

        document.getElementById('createSnapshotBtn').onclick = async () => {
            const api = API || getEda();
            if (!api || !api.jlc_eda_beautify_snapshot) {
                if (api && api.sys_Dialog) {
                    api.sys_Dialog.showInformationMessage('API not ready (jlc_eda_beautify_snapshot missing)');
                }
                else {
                    console.error('API not ready (jlc_eda_beautify_snapshot missing)');
                }
                return;
            }
            try {
                const name = api.sys_I18n ? api.sys_I18n.text('手动快照') : 'Manual Snapshot';
                await api.jlc_eda_beautify_snapshot.createSnapshot(name, true);
                await refreshSnapshots();
                showToast(api.sys_I18n ? api.sys_I18n.text('快照已创建') : 'Snapshot Created');
            }
            catch (e) {
                console.error('Create Snapshot Error:', e);
                if (api.sys_Dialog) {
                    api.sys_Dialog.showInformationMessage(`Create Snapshot Error: ${e}`);
                }
                else {
                    console.error(`Create Snapshot Error: ${e}`);
                }
            }
        };

        document.getElementById('clearSnapshotsBtn').onclick = () => {
            const api = API || getEda();
            if (!api || !api.jlc_eda_beautify_snapshot)
                return;
            const confirmText = api.sys_I18n ? api.sys_I18n.text('确定要清除所有手动快照吗？') : 'Clear all manual snapshots?';

            if (api.sys_Dialog) {
                api.sys_Dialog.showConfirmationMessage(confirmText, api.sys_I18n ? api.sys_I18n.text('清除手动快照') : 'Clear Manual Snapshots', undefined, undefined, async (ok) => {
                    if (ok) {
                        await api.jlc_eda_beautify_snapshot.clearSnapshots();
                        await refreshSnapshots();
                        showToast(api.sys_I18n ? api.sys_I18n.text('已清除') : 'Cleared');
                    }
                });
            }
        };

        // Init
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        }
        else {
            init();
        }

        // Global for polling
        let lastSnapshotCount = -1;

        function init() {
            loadSettings().then(() => {
                translatePage();
                refreshSnapshots();

                // Register snapshot change callback so the list auto-refreshes when main code creates/deletes snapshots
                const api = API || getEda();
                if (api && api.jlc_eda_beautify_snapshot && typeof api.jlc_eda_beautify_snapshot.registerSnapshotChangeCallback === 'function') {
                    // Use the explicit registration interface
                    api.jlc_eda_beautify_snapshot.registerSnapshotChangeCallback(() => {
                        refreshSnapshots().catch((err) => {
                            console.error('[Settings] Snapshot refresh failed:', err);
                        });
                    });
                    console.log('[Settings] Snapshot callback registered');
                }

                // Extra safety: poll for snapshot count changes
                const poller = async () => {
                    // Don't poll in manual mode
                    if (currentViewType === 'manual') return;

                    const currentApi = API || getEda();
                    if (!currentApi || !currentApi.jlc_eda_beautify_snapshot || !currentPcbId)
                        return;

                    try {
                        const snapshots = await currentApi.jlc_eda_beautify_snapshot.getSnapshots(currentPcbId, 'auto');

                        // Only redraw if count changed
                        if (snapshots.length !== lastSnapshotCount && lastSnapshotCount !== -1) {
                            refreshSnapshots();
                        }
                        lastSnapshotCount = snapshots.length;
                    }
                    catch {
                        // ignore polling errors
                    }
                };

                // Start polling (every 2 seconds)
                setInterval(poller, 2000);
            });
        }
	</script>
</body>
</html>
